/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';
/** This is shared code across all tensor creation methods. */
export function makeTensor(values, shape, inferredShape, dtype) {
    if (dtype == null) {
        dtype = inferDtype(values);
    }
    if (dtype === 'complex64') {
        throw new Error(`Cannot construct a complex64 tensor directly. ` +
            `Please use tf.complex(real, imag).`);
    }
    if (typeof values === 'object' && 'texture' in values) {
        if (dtype !== 'float32' && dtype !== 'int32') {
            throw new Error(`Creating tensor from texture only supports ` +
                `'float32'|'int32' dtype, while the dtype is ${dtype}.`);
        }
        values.channels = values.channels || 'RGBA';
        return ENGINE.backend.createTensorFromTexture(values, shape || inferredShape, dtype);
    }
    if (!isTypedArray(values) && !Array.isArray(values) &&
        typeof values !== 'number' && typeof values !== 'boolean' &&
        typeof values !== 'string') {
        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +
            'an array of numbers/booleans/strings, or a TypedArray');
    }
    // Verify that the shape matches the inferred shape.
    if (shape != null) {
        assertNonNegativeIntegerDimensions(shape);
        const providedSize = sizeFromShape(shape);
        const inferredSize = sizeFromShape(inferredShape);
        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +
            `${providedSize} values but has ${inferredSize}`);
        for (let i = 0; i < inferredShape.length; ++i) {
            const inferred = inferredShape[i];
            const flatDimsDontMatch = i === inferredShape.length - 1 ?
                inferred !== sizeFromShape(shape.slice(i)) :
                true;
            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +
                `(${inferredShape}) does not match the provided ` +
                `shape (${shape}). `);
        }
    }
    if (!isTypedArray(values) && !Array.isArray(values)) {
        values = [values];
    }
    shape = shape || inferredShape;
    values = dtype !== 'string' ?
        toTypedArray(values, dtype) :
        flatten(values, [], true);
    return ENGINE.makeTensor(values, shape, dtype);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX29wc191dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvdGVuc29yX29wc191dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFJakMsT0FBTyxFQUFDLE1BQU0sRUFBRSxrQ0FBa0MsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBRW5JLDhEQUE4RDtBQUM5RCxNQUFNLFVBQVUsVUFBVSxDQUN0QixNQUE0QixFQUFFLEtBQWUsRUFBRSxhQUF1QixFQUN0RSxLQUFnQjtJQUNsQixJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7UUFDakIsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUM1QjtJQUNELElBQUksS0FBSyxLQUFLLFdBQVcsRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUNYLGdEQUFnRDtZQUNoRCxvQ0FBb0MsQ0FBQyxDQUFDO0tBQzNDO0lBQ0QsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLElBQUksU0FBUyxJQUFJLE1BQU0sRUFBRTtRQUNyRCxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLE9BQU8sRUFBRTtZQUM1QyxNQUFNLElBQUksS0FBSyxDQUNYLDZDQUE2QztnQkFDN0MsK0NBQStDLEtBQUssR0FBRyxDQUFDLENBQUM7U0FDOUQ7UUFDRCxNQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDO1FBQzVDLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsQ0FDekMsTUFBTSxFQUFFLEtBQUssSUFBSSxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDNUM7SUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDL0MsT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLFNBQVM7UUFDekQsT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQzlCLE1BQU0sSUFBSSxLQUFLLENBQ1gscUVBQXFFO1lBQ3JFLHVEQUF1RCxDQUFDLENBQUM7S0FDOUQ7SUFDRCxvREFBb0Q7SUFDcEQsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO1FBQ2pCLGtDQUFrQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTFDLE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQyxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbEQsTUFBTSxDQUNGLFlBQVksS0FBSyxZQUFZLEVBQzdCLEdBQUcsRUFBRSxDQUNELGlDQUFpQyxLQUFLLDRCQUE0QjtZQUNsRSxHQUFHLFlBQVksbUJBQW1CLFlBQVksRUFBRSxDQUFDLENBQUM7UUFFMUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDN0MsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFLLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RELFFBQVEsS0FBSyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLElBQUksQ0FBQztZQUNULE1BQU0sQ0FDRixhQUFhLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQ25ELEdBQUcsRUFBRSxDQUFDLDhDQUE4QztnQkFDaEQsSUFBSSxhQUFhLGdDQUFnQztnQkFDakQsVUFBVSxLQUFLLEtBQUssQ0FBQyxDQUFDO1NBQy9CO0tBQ0Y7SUFFRCxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNuRCxNQUFNLEdBQUcsQ0FBQyxNQUFNLENBQWEsQ0FBQztLQUMvQjtJQUVELEtBQUssR0FBRyxLQUFLLElBQUksYUFBYSxDQUFDO0lBQy9CLE1BQU0sR0FBRyxLQUFLLEtBQUssUUFBUSxDQUFDLENBQUM7UUFDekIsWUFBWSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdCLE9BQU8sQ0FBQyxNQUFrQixFQUFFLEVBQUUsRUFBRSxJQUFJLENBQWEsQ0FBQztJQUN0RCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBb0IsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDL0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uL2VuZ2luZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7VGVuc29yTGlrZSwgVHlwZWRBcnJheSwgV2ViR0xEYXRhfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2Fzc2VydCwgYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucywgZmxhdHRlbiwgaW5mZXJEdHlwZSwgaXNUeXBlZEFycmF5LCBzaXplRnJvbVNoYXBlLCB0b1R5cGVkQXJyYXl9IGZyb20gJy4uL3V0aWwnO1xuXG4vKiogVGhpcyBpcyBzaGFyZWQgY29kZSBhY3Jvc3MgYWxsIHRlbnNvciBjcmVhdGlvbiBtZXRob2RzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VUZW5zb3IoXG4gICAgdmFsdWVzOiBUZW5zb3JMaWtlfFdlYkdMRGF0YSwgc2hhcGU6IG51bWJlcltdLCBpbmZlcnJlZFNoYXBlOiBudW1iZXJbXSxcbiAgICBkdHlwZT86IERhdGFUeXBlKTogVGVuc29yIHtcbiAgaWYgKGR0eXBlID09IG51bGwpIHtcbiAgICBkdHlwZSA9IGluZmVyRHR5cGUodmFsdWVzKTtcbiAgfVxuICBpZiAoZHR5cGUgPT09ICdjb21wbGV4NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGNvbnN0cnVjdCBhIGNvbXBsZXg2NCB0ZW5zb3IgZGlyZWN0bHkuIGAgK1xuICAgICAgICBgUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLmApO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJiAndGV4dHVyZScgaW4gdmFsdWVzKSB7XG4gICAgaWYgKGR0eXBlICE9PSAnZmxvYXQzMicgJiYgZHR5cGUgIT09ICdpbnQzMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ3JlYXRpbmcgdGVuc29yIGZyb20gdGV4dHVyZSBvbmx5IHN1cHBvcnRzIGAgK1xuICAgICAgICAgIGAnZmxvYXQzMid8J2ludDMyJyBkdHlwZSwgd2hpbGUgdGhlIGR0eXBlIGlzICR7ZHR5cGV9LmApO1xuICAgIH1cbiAgICB2YWx1ZXMuY2hhbm5lbHMgPSB2YWx1ZXMuY2hhbm5lbHMgfHwgJ1JHQkEnO1xuICAgIHJldHVybiBFTkdJTkUuYmFja2VuZC5jcmVhdGVUZW5zb3JGcm9tVGV4dHVyZShcbiAgICAgICAgdmFsdWVzLCBzaGFwZSB8fCBpbmZlcnJlZFNoYXBlLCBkdHlwZSk7XG4gIH1cbiAgaWYgKCFpc1R5cGVkQXJyYXkodmFsdWVzKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmXG4gICAgICB0eXBlb2YgdmFsdWVzICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWVzICE9PSAnYm9vbGVhbicgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGEgbnVtYmVyL2Jvb2xlYW4vc3RyaW5nIG9yICcgK1xuICAgICAgICAnYW4gYXJyYXkgb2YgbnVtYmVycy9ib29sZWFucy9zdHJpbmdzLCBvciBhIFR5cGVkQXJyYXknKTtcbiAgfVxuICAvLyBWZXJpZnkgdGhhdCB0aGUgc2hhcGUgbWF0Y2hlcyB0aGUgaW5mZXJyZWQgc2hhcGUuXG4gIGlmIChzaGFwZSAhPSBudWxsKSB7XG4gICAgYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucyhzaGFwZSk7XG5cbiAgICBjb25zdCBwcm92aWRlZFNpemUgPSBzaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICBjb25zdCBpbmZlcnJlZFNpemUgPSBzaXplRnJvbVNoYXBlKGluZmVycmVkU2hhcGUpO1xuICAgIGFzc2VydChcbiAgICAgICAgcHJvdmlkZWRTaXplID09PSBpbmZlcnJlZFNpemUsXG4gICAgICAgICgpID0+XG4gICAgICAgICAgICBgQmFzZWQgb24gdGhlIHByb3ZpZGVkIHNoYXBlLCBbJHtzaGFwZX1dLCB0aGUgdGVuc29yIHNob3VsZCBoYXZlIGAgK1xuICAgICAgICAgICAgYCR7cHJvdmlkZWRTaXplfSB2YWx1ZXMgYnV0IGhhcyAke2luZmVycmVkU2l6ZX1gKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5mZXJyZWRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaW5mZXJyZWQgPSBpbmZlcnJlZFNoYXBlW2ldO1xuICAgICAgY29uc3QgZmxhdERpbXNEb250TWF0Y2ggPSBpID09PSBpbmZlcnJlZFNoYXBlLmxlbmd0aCAtIDEgP1xuICAgICAgICAgIGluZmVycmVkICE9PSBzaXplRnJvbVNoYXBlKHNoYXBlLnNsaWNlKGkpKSA6XG4gICAgICAgICAgdHJ1ZTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgICBpbmZlcnJlZFNoYXBlW2ldID09PSBzaGFwZVtpXSB8fCAhZmxhdERpbXNEb250TWF0Y2gsXG4gICAgICAgICAgKCkgPT4gYEVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgYCArXG4gICAgICAgICAgICAgIGAoJHtpbmZlcnJlZFNoYXBlfSkgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIGAgK1xuICAgICAgICAgICAgICBgc2hhcGUgKCR7c2hhcGV9KS4gYCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc1R5cGVkQXJyYXkodmFsdWVzKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgdmFsdWVzID0gW3ZhbHVlc10gYXMgbnVtYmVyW107XG4gIH1cblxuICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gIHZhbHVlcyA9IGR0eXBlICE9PSAnc3RyaW5nJyA/XG4gICAgICB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgOlxuICAgICAgZmxhdHRlbih2YWx1ZXMgYXMgc3RyaW5nW10sIFtdLCB0cnVlKSBhcyBzdHJpbmdbXTtcbiAgcmV0dXJuIEVOR0lORS5tYWtlVGVuc29yKHZhbHVlcyBhcyBUeXBlZEFycmF5LCBzaGFwZSwgZHR5cGUpO1xufVxuIl19