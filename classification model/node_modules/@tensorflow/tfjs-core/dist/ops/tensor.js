/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { inferShape } from '../tensor_util_env';
import { makeTensor } from './tensor_ops_util';
/**
 * Creates a `tf.Tensor` with the provided values, shape and dtype.
 *
 * ```js
 * // Pass an array of values to create a vector.
 * tf.tensor([1, 2, 3, 4]).print();
 * ```
 *
 * ```js
 * // Pass a nested array of values to make a matrix or a higher
 * // dimensional tensor.
 * tf.tensor([[1, 2], [3, 4]]).print();
 * ```
 *
 * ```js
 * // Pass a flat array and specify a shape yourself.
 * tf.tensor([1, 2, 3, 4], [2, 2]).print();
 * ```
 *
 * ```js
 * // Pass a `WebGLData` object and specify a shape yourself.
 *
 * // This makes it possible for TF.js applications to avoid GPU / CPU sync.
 * // For example, if your application includes a preprocessing step on the GPU,
 * // you could upload the GPU output directly to TF.js, rather than first
 * // downloading the values.
 *
 * // Example for WebGL2:
 * const customCanvas = document.createElement('canvas');
 * const customBackend = new tf.MathBackendWebGL(customCanvas);
 * tf.registerBackend('custom-webgl', () => customBackend);
 * await tf.setBackend('custom-webgl');
 * const gl = customBackend.gpgpu.gl;
 * const texture = gl.createTexture();
 * const tex2d = gl.TEXTURE_2D;
 * const width = 2;
 * const height = 2;
 *
 * gl.bindTexture(tex2d, texture);
 * gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
 * gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
 * gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
 * gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
 * gl.texImage2D(
 *   tex2d, 0, gl.RGBA32F, // internalFormat
 *   width, height, 0,
 *   gl.RGBA, // textureFormat
 *   gl.FLOAT, // textureType
 *   new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
 * );
 *
 * // Currently, the `texture` has 4 pixels:
 * // Pixel0 is {R:0, G:1, B:2, A:3}
 * // Pixel1 is {R:4, G:5, B:6, A:7}
 * // Pixel2 is {R:8, G:9, B:10, A:11}
 * // Pixel3 is {R:12, G:13, B:14, A:15}
 *
 * const logicalShape = [height * width * 2];
 * const a = tf.tensor({texture, height, width, channels: 'BR'}, logicalShape);
 * // Tensor value will be [2, 0, 6, 4, 10, 8, 14, 12], since [2, 0] is the
 * // values of 'B' and 'R' channels of Pixel0, [6, 4] is the values of 'B' and
 * 'R'
 * // channels of Pixel1...
 *
 * // For postprocessing on the GPU, it's possible to retrieve the texture
 * // backing any tensor by calling the tensor's `dataToGPU` method like
 * // so:
 *
 * const tex = a.dataToGPU();
 * ```
 * @param values The values of the tensor. Can be nested array of numbers,
 *     or a flat array, or a `TypedArray`, or a `WebGLData` object. If the
 * values are strings, they will be encoded as utf-8 and kept as `Uint8Array[]`.
 * If the values is a `WebGLData` object, the dtype could only be 'float32' or
 * 'int32' and the object has to have: 1. texture, a `WebGLTexture`, the texture
 * must share the same `WebGLRenderingContext` with TFJS's WebGL backend (you
 * could create a custom WebGL backend from your texture's canvas) and the
 * internal texture format for the input texture must be floating point or
 * normalized integer; 2. height, the height of the texture; 3. width, the width
 * of the texture; 4. channels, a non-empty subset of 'RGBA', indicating the
 * values of which channels will be passed to the tensor, such as 'R' or 'BR'
 * (The order of the channels affect the order of tensor values. ). (If the
 * values passed from texture is less than the tensor size, zeros will be padded
 * at the rear.)
 * @param shape The shape of the tensor. Optional. If not provided,
 *   it is inferred from `values`.
 * @param dtype The data type.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */
export function tensor(values, shape, dtype) {
    const inferredShape = inferShape(values, dtype);
    return makeTensor(values, shape, inferredShape, dtype);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvdGVuc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUk5QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUZHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FDbEIsTUFBNEIsRUFBRSxLQUFtQixFQUNqRCxLQUFnQjtJQUNsQixNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2hELE9BQU8sVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBYyxDQUFDO0FBQ3RFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtpbmZlclNoYXBlfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge0RhdGFUeXBlLCBSYW5rLCBTaGFwZU1hcCwgV2ViR0xEYXRhfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7bWFrZVRlbnNvcn0gZnJvbSAnLi90ZW5zb3Jfb3BzX3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgdGYuVGVuc29yYCB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHNoYXBlIGFuZCBkdHlwZS5cbiAqXG4gKiBgYGBqc1xuICogLy8gUGFzcyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gY3JlYXRlIGEgdmVjdG9yLlxuICogdGYudGVuc29yKFsxLCAyLCAzLCA0XSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBQYXNzIGEgbmVzdGVkIGFycmF5IG9mIHZhbHVlcyB0byBtYWtlIGEgbWF0cml4IG9yIGEgaGlnaGVyXG4gKiAvLyBkaW1lbnNpb25hbCB0ZW5zb3IuXG4gKiB0Zi50ZW5zb3IoW1sxLCAyXSwgWzMsIDRdXSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBQYXNzIGEgZmxhdCBhcnJheSBhbmQgc3BlY2lmeSBhIHNoYXBlIHlvdXJzZWxmLlxuICogdGYudGVuc29yKFsxLCAyLCAzLCA0XSwgWzIsIDJdKS5wcmludCgpO1xuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIFBhc3MgYSBgV2ViR0xEYXRhYCBvYmplY3QgYW5kIHNwZWNpZnkgYSBzaGFwZSB5b3Vyc2VsZi5cbiAqXG4gKiAvLyBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBURi5qcyBhcHBsaWNhdGlvbnMgdG8gYXZvaWQgR1BVIC8gQ1BVIHN5bmMuXG4gKiAvLyBGb3IgZXhhbXBsZSwgaWYgeW91ciBhcHBsaWNhdGlvbiBpbmNsdWRlcyBhIHByZXByb2Nlc3Npbmcgc3RlcCBvbiB0aGUgR1BVLFxuICogLy8geW91IGNvdWxkIHVwbG9hZCB0aGUgR1BVIG91dHB1dCBkaXJlY3RseSB0byBURi5qcywgcmF0aGVyIHRoYW4gZmlyc3RcbiAqIC8vIGRvd25sb2FkaW5nIHRoZSB2YWx1ZXMuXG4gKlxuICogLy8gRXhhbXBsZSBmb3IgV2ViR0wyOlxuICogY29uc3QgY3VzdG9tQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gKiBjb25zdCBjdXN0b21CYWNrZW5kID0gbmV3IHRmLk1hdGhCYWNrZW5kV2ViR0woY3VzdG9tQ2FudmFzKTtcbiAqIHRmLnJlZ2lzdGVyQmFja2VuZCgnY3VzdG9tLXdlYmdsJywgKCkgPT4gY3VzdG9tQmFja2VuZCk7XG4gKiBhd2FpdCB0Zi5zZXRCYWNrZW5kKCdjdXN0b20td2ViZ2wnKTtcbiAqIGNvbnN0IGdsID0gY3VzdG9tQmFja2VuZC5ncGdwdS5nbDtcbiAqIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gKiBjb25zdCB0ZXgyZCA9IGdsLlRFWFRVUkVfMkQ7XG4gKiBjb25zdCB3aWR0aCA9IDI7XG4gKiBjb25zdCBoZWlnaHQgPSAyO1xuICpcbiAqIGdsLmJpbmRUZXh0dXJlKHRleDJkLCB0ZXh0dXJlKTtcbiAqIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAqIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAqIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gKiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICogZ2wudGV4SW1hZ2UyRChcbiAqICAgdGV4MmQsIDAsIGdsLlJHQkEzMkYsIC8vIGludGVybmFsRm9ybWF0XG4gKiAgIHdpZHRoLCBoZWlnaHQsIDAsXG4gKiAgIGdsLlJHQkEsIC8vIHRleHR1cmVGb3JtYXRcbiAqICAgZ2wuRkxPQVQsIC8vIHRleHR1cmVUeXBlXG4gKiAgIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdKVxuICogKTtcbiAqXG4gKiAvLyBDdXJyZW50bHksIHRoZSBgdGV4dHVyZWAgaGFzIDQgcGl4ZWxzOlxuICogLy8gUGl4ZWwwIGlzIHtSOjAsIEc6MSwgQjoyLCBBOjN9XG4gKiAvLyBQaXhlbDEgaXMge1I6NCwgRzo1LCBCOjYsIEE6N31cbiAqIC8vIFBpeGVsMiBpcyB7Ujo4LCBHOjksIEI6MTAsIEE6MTF9XG4gKiAvLyBQaXhlbDMgaXMge1I6MTIsIEc6MTMsIEI6MTQsIEE6MTV9XG4gKlxuICogY29uc3QgbG9naWNhbFNoYXBlID0gW2hlaWdodCAqIHdpZHRoICogMl07XG4gKiBjb25zdCBhID0gdGYudGVuc29yKHt0ZXh0dXJlLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsczogJ0JSJ30sIGxvZ2ljYWxTaGFwZSk7XG4gKiAvLyBUZW5zb3IgdmFsdWUgd2lsbCBiZSBbMiwgMCwgNiwgNCwgMTAsIDgsIDE0LCAxMl0sIHNpbmNlIFsyLCAwXSBpcyB0aGVcbiAqIC8vIHZhbHVlcyBvZiAnQicgYW5kICdSJyBjaGFubmVscyBvZiBQaXhlbDAsIFs2LCA0XSBpcyB0aGUgdmFsdWVzIG9mICdCJyBhbmRcbiAqICdSJ1xuICogLy8gY2hhbm5lbHMgb2YgUGl4ZWwxLi4uXG4gKlxuICogLy8gRm9yIHBvc3Rwcm9jZXNzaW5nIG9uIHRoZSBHUFUsIGl0J3MgcG9zc2libGUgdG8gcmV0cmlldmUgdGhlIHRleHR1cmVcbiAqIC8vIGJhY2tpbmcgYW55IHRlbnNvciBieSBjYWxsaW5nIHRoZSB0ZW5zb3IncyBgZGF0YVRvR1BVYCBtZXRob2QgbGlrZVxuICogLy8gc286XG4gKlxuICogY29uc3QgdGV4ID0gYS5kYXRhVG9HUFUoKTtcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIG9mIHRoZSB0ZW5zb3IuIENhbiBiZSBuZXN0ZWQgYXJyYXkgb2YgbnVtYmVycyxcbiAqICAgICBvciBhIGZsYXQgYXJyYXksIG9yIGEgYFR5cGVkQXJyYXlgLCBvciBhIGBXZWJHTERhdGFgIG9iamVjdC4gSWYgdGhlXG4gKiB2YWx1ZXMgYXJlIHN0cmluZ3MsIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIHV0Zi04IGFuZCBrZXB0IGFzIGBVaW50OEFycmF5W11gLlxuICogSWYgdGhlIHZhbHVlcyBpcyBhIGBXZWJHTERhdGFgIG9iamVjdCwgdGhlIGR0eXBlIGNvdWxkIG9ubHkgYmUgJ2Zsb2F0MzInIG9yXG4gKiAnaW50MzInIGFuZCB0aGUgb2JqZWN0IGhhcyB0byBoYXZlOiAxLiB0ZXh0dXJlLCBhIGBXZWJHTFRleHR1cmVgLCB0aGUgdGV4dHVyZVxuICogbXVzdCBzaGFyZSB0aGUgc2FtZSBgV2ViR0xSZW5kZXJpbmdDb250ZXh0YCB3aXRoIFRGSlMncyBXZWJHTCBiYWNrZW5kICh5b3VcbiAqIGNvdWxkIGNyZWF0ZSBhIGN1c3RvbSBXZWJHTCBiYWNrZW5kIGZyb20geW91ciB0ZXh0dXJlJ3MgY2FudmFzKSBhbmQgdGhlXG4gKiBpbnRlcm5hbCB0ZXh0dXJlIGZvcm1hdCBmb3IgdGhlIGlucHV0IHRleHR1cmUgbXVzdCBiZSBmbG9hdGluZyBwb2ludCBvclxuICogbm9ybWFsaXplZCBpbnRlZ2VyOyAyLiBoZWlnaHQsIHRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmU7IDMuIHdpZHRoLCB0aGUgd2lkdGhcbiAqIG9mIHRoZSB0ZXh0dXJlOyA0LiBjaGFubmVscywgYSBub24tZW1wdHkgc3Vic2V0IG9mICdSR0JBJywgaW5kaWNhdGluZyB0aGVcbiAqIHZhbHVlcyBvZiB3aGljaCBjaGFubmVscyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVuc29yLCBzdWNoIGFzICdSJyBvciAnQlInXG4gKiAoVGhlIG9yZGVyIG9mIHRoZSBjaGFubmVscyBhZmZlY3QgdGhlIG9yZGVyIG9mIHRlbnNvciB2YWx1ZXMuICkuIChJZiB0aGVcbiAqIHZhbHVlcyBwYXNzZWQgZnJvbSB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGUgdGVuc29yIHNpemUsIHplcm9zIHdpbGwgYmUgcGFkZGVkXG4gKiBhdCB0aGUgcmVhci4pXG4gKiBAcGFyYW0gc2hhcGUgVGhlIHNoYXBlIG9mIHRoZSB0ZW5zb3IuIE9wdGlvbmFsLiBJZiBub3QgcHJvdmlkZWQsXG4gKiAgIGl0IGlzIGluZmVycmVkIGZyb20gYHZhbHVlc2AuXG4gKiBAcGFyYW0gZHR5cGUgVGhlIGRhdGEgdHlwZS5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbid9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW5zb3I8UiBleHRlbmRzIFJhbms+KFxuICAgIHZhbHVlczogVGVuc29yTGlrZXxXZWJHTERhdGEsIHNoYXBlPzogU2hhcGVNYXBbUl0sXG4gICAgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvcjxSPiB7XG4gIGNvbnN0IGluZmVycmVkU2hhcGUgPSBpbmZlclNoYXBlKHZhbHVlcywgZHR5cGUpO1xuICByZXR1cm4gbWFrZVRlbnNvcih2YWx1ZXMsIHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBkdHlwZSkgYXMgVGVuc29yPFI+O1xufVxuIl19